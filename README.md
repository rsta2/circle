Circle
======

> This is Step 4 of Circle. To get access to Step 1-3 use the git tag "Step1" to "Step3".

> If you read this file in an editor you should switch line wrapping on.

Overview
--------

Circle is a C++ bare metal environment for the Raspberry Pi. Currently it should run on all existing models but I can only test it on model B and B+. This is the last step which should run on model A because of the required on-board USB hub in the next step.

Circle will be developed and released step by step. So it may be easier to understand. The main goal was to setup the classes needed for the USB stack until now. This is completed. We start with USB in step 5.

The 4th Step
------------

First blink 5 times to show the image was loaded right. After initializing most things the timer interrupt is on and the delay loop will be calibrated. You can "listen" to the timer interrupt at the 3.5mm headphone jack. The output level is inverted on every interrupt. A kernel timer is started to elapse after 15 seconds. Furthermore a log message is generated on every second.

When the kernel timer elapses TimerHandler() is called where a "Prefetch Abort" is generated by jumping to an invalid address (execute never bit is set in the page table for it). Alternatively you can generate an "Undefined Instruction" exception. This is for demonstrating the exception handler.

The options to be used for *cmdline.txt* are described in *doc/cmdline.txt* now.

Circle has the following new features:

* Using interrupts
* Timer class with clock, timers and calibrated delay loop
* Exception handler

In Step 1-3 the following features were introduced:

* C++ build environment
* Simple delay functionality
* Get properties (model, memory size) from VideoCore
* new and delete
* Using GPIO pins
* Manipulating Act LED
* Set pixel on screen
* Use kernel options
* Switch on MMU
* Formatting strings
* Using devices
* Writing characters to screen
* Writing characters to UART
* Logging output to screen or UART
* Using assertions and debug hexdump

Building
--------

Building is normally done on PC Linux. You need a [toolchain](http://elinux.org/Rpi_Software#ARM) for the ARM1176JZF core. First edit the file *Rules.mk* and set the PREFIX of your toolchain commands. Then go to the build root of Circle and do:

`./makeall clean`  
`./makeall`

The ready build *kernel.img* file should be in the sample/ directory.

---

Building Circle for the Raspberry Pi from a non-Linux host remains possible. You need a cross compiler targetting *for example* `arm-none-eabi`. OSDev.org has an [excellent document on the subject](http://wiki.osdev.org/GCC_Cross-Compiler) that you can follow if you have no idea of what a cross compiler is, or how to make one.

When your compiler is ready, you need to tell the building process which compiler you are using. Create a Config.mk file and set the `PREFIX` variable to the prefix of your compiler. It should look like this:

```
	# Config.mk
	# Circle build configuration file
	
	PREFIX = arm-none-eabi- # don't forget the dash at the end
```

When it's done, type in the two `makeall` commands shown above. The ready build *kernel.img* file should be in the sample/ directory.

---

You can also build Circle on the Raspberry Pi itself on Debian wheezy but you need some method to put the *kernel.img* file onto the SD(HC) card. With an external USB card reader on model B+ (4 USB ports) this should be no problem.


Installation
------------

Copy the Raspberry Pi firmware (from boot/ directory, do *make* there to get them) files along with the kernel.img (from sample/ directory) to a SD(HC) card with FAT file system. Put the SD(HC) card into the Raspberry Pi.

Directories
-----------

* include: The common header files, most class headers are in the include/circle/ subdirectory.
* lib: The Circle class implementation and support files.
* sample: A sample application using Circle. The main function is implemented in the CKernel class.
* boot: Do *make* in this directory to get the Raspberry Pi firmware files required to boot.
* doc: Additional documentation files.

Classes
-------

The following C++ classes were added to the Circle library in the lib/ subdirectory:

* CExceptionHandler: Generates a stack-trace and a panic message if an abort exception occurs.
* CInterruptSystem: Connecting to interrupts, an interrupt handler will be called on interrupt.
* CTimer: Supports an uptime clock, kernel timers and a calibrated delay loop.

In Step 1-3 the following classes were introduced:

* CActLED: Switch the Act LED on and off, checks the Raspberry Pi model to use the right LED pin.
* CBcmMailBox: Simple GPU mailbox interface, currently used for the property interface.
* CBcmPropertyTags: Get several information from the GPU side or control something on this side.
* CGPIOPin: Encapsulates a GPIO pin, can be read, write or inverted. Simple initialization.
* CBcmFrameBuffer: Frame buffer initialization, setting color palette for 8 bit depth.
* CKernelOptions: Providing kernel options from file cmdline.txt (see *doc/cmdline.txt*).
* CMemorySystem: Enabling MMU if requested, switching page tables (not used here).
* CPageTable: Encapsulates a page table to be used by MMU.
* CCharGenerator: Gives pixel information for console font
* CDevice: Base class for all devices
* CDeviceNameService: Devices can be registered by name and retrieved later by this name
* CLogger: Writing logging messages to a target device
* CScreenDevice: Writing characters to screen, some escape sequences (some are not yet implemented)
* CSerialDevice: Writing characters to UART
* CString: Simple string manipulation class, Format() method works like printf() (but has less formating options)
